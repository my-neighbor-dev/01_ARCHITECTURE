# 8. 정리 및 Q&A

## 핵심 정리

### 1. Role 기반 인가의 한계

- Role 기반 인가는 "무엇을 할 수 있는가"만 체크하고, "누구의 데이터인가"는 체크하지 못함
- 권한을 가진 사용자가 다른 데이터의 key 값을 알아내 악의적인 수정하는 데이터 침범 위험 발생
- 데이터 소유권 체크가 필요하지만, 도메인별로 다른 조건이 있어 복잡함

---

### 2. 단순한 접근의 한계

**시도 1: 모든 메서드에 check() 로직 넣기**
- 중복 코드: 수십 개의 메서드마다 똑같은 검증 로직
- 가독성 저하: 비즈니스 로직과 보안 로직 혼재

**시도 2: 공통 검증 로직 사용하기**
- 중복 코드는 해결되었지만, 비즈니스 로직과 보안 로직이 여전히 혼재

---

### 3. AOP + 전략 패턴으로 해결

- **AOP**: 비즈니스 로직을 건드리지 않고 보안 로직을 추가
- **전략 패턴**: 도메인별 다른 검증 로직을 유연하게 처리
- **Annotation 기반**: 반복되는 권한 체크 로직을 공통화

**핵심 흐름:**
```
Request → Aspect (ID 추출 → DB 조회 → 검증) → Orchestrator (순수 비즈니스 로직) → Response
```

---

### 4. 구현 단계

1. **ResourceOwnership 인터페이스**: 도메인별 소유권 ID 통일
2. **전략 패턴(Enum)**: 검증 로직 추상화 (USER vs GROUP)
3. **DomainFinder 인터페이스**: 도메인 조회 추상화
4. **Annotation & Aspect**: 비즈니스 로직과 보안 로직 분리

---

### 5. 실제 사용

- Annotation만 붙이면 자동으로 데이터 소유권 체크 수행
- 도메인별 Annotation을 만들어 더 간편하게 사용 가능
- Orchestrator에서 보안 로직이 완전히 제거되어 비즈니스 로직만 남음

---

### 6. 문제 해결 중심의 이력서 작성

- 문제 상황을 명확하게 표현 (Role 기반 인가의 한계)
- 해결 방법을 구체적으로 설명 (AOP + 전략 패턴)
- 기술 선택 이유를 포함 (비즈니스 로직과 보안 로직 분리)

---

## Q&A

### Q1: AOP를 사용하면 성능에 영향을 주지 않나요?

**A:**
- AOP 적용을 위해 Aspect에서 applicationContext.getBean을 통해 빈을 조회하고 리플렉션을 사용하는 과정에서 발생하는 복잡도와 비용이 있습니다
- 하지만 리플렉션에 드는 비용은 실제 DB IO 비용에 비하면 매우 적기 때문에, 비즈니스 로직의 가독성과 유지보수성을 챙기는 것이 훨씬 유의미한 결정이라고 판단했습니다
- 실제로 대부분의 Spring 애플리케이션에서 AOP는 널리 사용되고 있으며, 성능 문제는 거의 발생하지 않습니다

---

### Q2: 도메인별로 다른 Annotation을 만드는 게 필수인가요?

**A:**
- 필수는 아닙니다. `@CheckDataPermission`을 직접 사용할 수도 있습니다
- 하지만 도메인별 Annotation을 만들면:
  - 더 간편하게 사용 가능
  - 도메인별로 다른 설정을 명확하게 표현
  - 실수로 잘못된 finder나 type을 지정하는 것을 방지
- 따라서 실무에서는 도메인별 Annotation을 만드는 것을 권장합니다

---

### Q3: 검증 로직을 수정하려면 어떻게 해야 하나요?

**A:**
- `DataPermissionCheckType` Enum의 `validate` 메서드를 수정하면 됩니다
- 모든 도메인에 자동으로 적용되므로 한 곳만 수정하면 됩니다
- 새로운 검증 타입이 필요하면 Enum에 추가하면 됩니다

**예시:**
```java
public enum DataPermissionCheckType {
    USER { ... },
    GROUP { ... },
    DEPARTMENT {  // 새로운 검증 타입 추가
        @Override
        public void validate(ResourceOwnership resource, UserInfo user) {
            // 부서 단위 검증 로직
        }
    }
}
```

---

### Q4: Aspect에서 예외가 발생하면 어떻게 되나요?

**A:**
- 검증 실패 시 `AccessDeniedException`이 발생합니다
- 이 예외는 Spring Security의 기본 예외 처리 메커니즘에 의해 처리됩니다
- 필요하다면 `@ControllerAdvice`를 사용하여 커스텀 예외 처리도 가능합니다

---

### Q5: 여러 개의 ID를 검증해야 한다면?

**A:**
- 현재 구현은 하나의 `@PermissionId`만 지원합니다
- 여러 개의 ID를 검증해야 한다면:
  1. 각 ID마다 별도의 Annotation을 만들거나
  2. Aspect를 수정하여 여러 개의 `@PermissionId`를 지원하도록 확장할 수 있습니다
- 하지만 대부분의 경우 하나의 ID만 검증하면 충분합니다

---

### Q6: 검증 로직을 비동기로 처리할 수 있나요?

**A:**
- 권장하지 않습니다
- 보안 검증은 요청 처리 전에 반드시 완료되어야 합니다
- 비동기로 처리하면 검증이 완료되기 전에 비즈니스 로직이 실행될 수 있어 보안 위험이 있습니다

---

## 스터디 후 확인할 내용

스터디를 듣고 나서 다음을 확인해보세요:

1. ✅ Role 기반 인가의 한계를 이해할 수 있는가?
2. ✅ 데이터 소유권 체크가 왜 필요한지 설명할 수 있는가?
3. ✅ AOP를 활용하여 비즈니스 로직과 보안 로직을 분리할 수 있는가?
4. ✅ 전략 패턴으로 도메인별 다른 검증 로직을 처리할 수 있는가?
5. ✅ 이력서에 문제 해결 중심으로 작성할 수 있는가?

---

## 실무 적용 체크리스트

### AOP 기반 인가 구현

- [ ] ResourceOwnership 인터페이스를 정의했는가?
- [ ] 도메인 모델이 ResourceOwnership을 구현하는가?
- [ ] DataPermissionCheckType Enum으로 검증 로직을 추상화했는가?
- [ ] DomainFinder 인터페이스를 정의했는가?
- [ ] SearchService가 DomainFinder를 구현하는가?
- [ ] DataPermissionAspect를 구현했는가?
- [ ] Annotation을 사용하여 검증이 필요한 메서드를 표시하는가?

### 코드 품질

- [ ] 비즈니스 로직과 보안 로직이 분리되어 있는가?
- [ ] 코드 중복이 제거되었는가?
- [ ] 가독성이 향상되었는가?
- [ ] 유지보수가 용이한가?

---

## 다음 단계

### 실습 과제

필수는 아니지만 개인 프로젝트에 한번 적용해보시는 걸 추천합니다!

1. **기존 프로젝트에 적용해보기**
   - ResourceOwnership 인터페이스 정의
   - DataPermissionCheckType Enum 구현
   - DomainFinder 인터페이스 정의
   - DataPermissionAspect 구현
   - Annotation 기반으로 검증 적용

2. **Before/After 비교**
   - 기존 코드와 개선된 코드 비교
   - 어떤 점이 개선되었는지 정리

3. **이력서에 작성하기**
   - "Role 기반 인가만으로는 데이터 소유권을 체크할 수 없어 다른 사용자 데이터 침범 위험 해결"
   - "AOP와 전략 패턴을 활용하여 비즈니스 로직과 보안 로직 분리"
   - "Annotation 기반으로 반복되는 권한 체크 로직을 공통화하여 코드 중복 제거"

---

## 핵심 메시지

> **"결국 중요한 건 '구현 기술'보다 '어떤 문제를 풀 것인가'를 정의하는 힘이다"**

### 오늘 배운 것

1. ✅ **Role 기반 인가는 "무엇을 할 수 있는가"만 체크하고, "누구의 데이터인가"는 체크하지 못한다**
2. ✅ **데이터 소유권 체크는 반복되는 보안 로직이지만, 비즈니스 로직과 분리되어야 한다**
3. ✅ **AOP를 활용하면 비즈니스 로직을 건드리지 않고 보안 로직을 추가할 수 있다**
4. ✅ **전략 패턴으로 도메인별 다른 검증 로직을 유연하게 처리할 수 있다**
5. ✅ **Annotation 기반으로 간편하게 사용 가능하며, 코드 중복을 제거할 수 있다**

---

## 마무리

이번 스터디를 통해 다음을 배웠습니다:

- ✅ Role 기반 인가의 한계와 데이터 소유권 체크의 필요성
- ✅ 단순한 접근의 문제점과 AOP + 전략 패턴으로 해결하는 방법
- ✅ 구체적인 구현 단계와 실제 사용 예시
- ✅ 문제 해결 중심의 이력서 작성 방법

질문이 있으시면 언제든지 물어보세요! 😊
