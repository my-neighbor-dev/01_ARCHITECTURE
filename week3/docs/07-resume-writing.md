# 7. 이력서 작성 가이드

## 질문

> **"이 내용을 이력서에 어떻게 쓸까요?"**

> 💡 **스터디 전에 생각해보기**: [질문들 모음](./00-questions.md)을 먼저 확인해보세요!

**생각해볼 점:**
- "Spring Security를 활용한 인증/인가 구현" 같은 뻔한 예시와 어떻게 다를까?
- 문제 상황을 어떻게 명확하게 표현할까?
- AOP와 전략 패턴을 선택한 이유를 어떻게 설명할까?

---

## 7.1 Before/After 비교

### Before: 뻔한 예시

```jsx
[프로젝트 A]
Trouble Shooting
- Spring Security를 활용한 인증/인가 구현
- JWT 토큰 기반 인증 시스템 구축
- Role 기반 권한 제어 구현
```

**문제점:**
- 어떤 문제인지 명확하지 않음
- 기술 스택만 나열
- 해결 과정이 보이지 않음

---

### After: 문제 해결 중심

```jsx
[프로젝트 A]
Trouble Shooting
- Role 기반 인가만으로는 데이터 소유권을 체크할 수 없어 다른 사용자 데이터 침범 위험 해결
- AOP와 전략 패턴을 활용하여 비즈니스 로직과 보안 로직 분리
- Annotation 기반으로 반복되는 권한 체크 로직을 공통화하여 코드 중복 제거
```

**장점:**
- 문제 상황 명확 (Role 기반 인가의 한계)
- 해결 방법 구체적 (AOP + 전략 패턴)
- 기술 선택 이유 암시 (비즈니스 로직과 보안 로직 분리)

---

## 7.2 작성 가이드

### 1. 문제 상황 명시

**좋은 예:**
- "Role 기반 인가만으로는 데이터 소유권을 체크할 수 없어 다른 사용자 데이터 침범 위험 해결"
- "권한을 가진 사용자가 다른 데이터의 key 값을 알아내 악의적인 수정하는 문제 발생"
- "도메인별로 다른 소유권 조건(그룹 단위 vs 사용자 단위)을 처리해야 하는 요구사항"

**나쁜 예:**
- "인가 기능 구현"
- "권한 체크 로직 추가"
- "보안 강화"

---

### 2. 해결 방법 설명

**좋은 예:**
- "AOP와 전략 패턴을 활용하여 비즈니스 로직과 보안 로직 분리"
- "Annotation 기반으로 반복되는 권한 체크 로직을 공통화"
- "ResourceOwnership 인터페이스와 DomainFinder 패턴으로 도메인별 소유권 체크 추상화"

**나쁜 예:**
- "AOP를 사용하여"
- "Annotation으로 구현"
- "인터페이스 활용"

---

### 3. 기술 선택 이유

**좋은 예:**
- "비즈니스 로직을 건드리지 않고 보안 로직을 추가하기 위해 AOP 선택"
- "도메인별 다른 검증 로직을 유연하게 처리하기 위해 전략 패턴(Enum) 활용"
- "코드 중복을 제거하고 가독성을 향상시키기 위해 Annotation 기반 공통화"

**나쁜 예:**
- "AOP가 좋아서"
- "전략 패턴을 사용"
- "Annotation이 편해서"

---

### 4. 구현 내용 간단히

**좋은 예:**
- "Annotation만 붙이면 자동으로 데이터 소유권 체크 수행"
- "도메인별 Annotation(@CheckLecturePermission 등)을 만들어 간편하게 사용"
- "50개 이상의 메서드에서 중복되던 검증 로직을 공통화하여 유지보수성 향상"

**나쁜 예:**
- "권한 체크 구현"
- "Annotation 추가"
- "코드 개선"

---

## 7.3 완성 예시

### 예시 1: 간단한 버전

```jsx
[프로젝트 A]
Trouble Shooting
- Role 기반 인가만으로는 데이터 소유권을 체크할 수 없어 다른 사용자 데이터 침범 위험 해결
- AOP와 전략 패턴을 활용하여 비즈니스 로직과 보안 로직 분리
- Annotation 기반으로 반복되는 권한 체크 로직을 공통화하여 코드 중복 제거
```

---

### 예시 2: 상세한 버전

```jsx
[프로젝트 A]
Trouble Shooting
- Role 기반 인가만으로는 데이터 소유권을 체크할 수 없어 다른 사용자 데이터 침범 위험 해결
- AOP와 전략 패턴을 활용하여 비즈니스 로직과 보안 로직 분리
- Annotation 기반으로 반복되는 권한 체크 로직을 공통화하여 코드 중복 제거
- ResourceOwnership 인터페이스와 DomainFinder 패턴으로 도메인별 소유권 체크 추상화
- 도메인별 다른 검증 조건(그룹 단위 vs 사용자 단위)을 Enum 전략 패턴으로 유연하게 처리
```

---

### 예시 3: 문제 해결 과정 강조

```jsx
[프로젝트 A]
Trouble Shooting
- 문제: Role 기반 인가만으로는 "무엇을 할 수 있는가"만 체크하고 "누구의 데이터인가"는 체크하지 못함
- 해결: AOP와 전략 패턴을 활용하여 데이터 소유권 기반 인가 제어 구현
- 결과: 50개 이상의 메서드에서 중복되던 검증 로직을 Annotation 기반으로 공통화하여 유지보수성 향상
- 기술 선택 이유: 비즈니스 로직을 건드리지 않고 보안 로직을 추가하기 위해 AOP 선택
```

---

## 7.4 면접 대비 질문

### 질문 1: "왜 AOP를 선택했나요?"

**답변:**
- "비즈니스 로직을 건드리지 않고 보안 로직을 추가하기 위해 AOP를 선택했습니다"
- "모든 메서드에 검증 로직을 넣으면 코드 중복이 발생하고, 비즈니스 로직과 보안 로직이 섞여 가독성이 떨어졌습니다"
- "AOP를 사용하면 Annotation만 붙이면 자동으로 검증이 수행되어 코드가 깔끔해집니다"

---

### 질문 2: "전략 패턴을 왜 Enum으로 구현했나요?"

**답변:**
- "검증 로직이 간단했기 때문에 별도의 클래스로 분리할 필요가 없었습니다"
- "Enum으로 깔끔하게 구현할 수 있었고, 새로운 검증 타입 추가도 쉬웠습니다"
- "도메인별로 다른 검증 조건(그룹 단위 vs 사용자 단위)을 유연하게 처리할 수 있었습니다"

---

### 질문 3: "AOP의 단점은 없나요?"

**답변:**
- "AOP 적용을 위해 Aspect에서 applicationContext.getBean을 통해 빈을 조회하고 리플렉션을 사용하는 과정에서 발생하는 복잡도와 비용이 있습니다"
- "하지만 리플렉션에 드는 비용은 실제 DB IO 비용에 비하면 매우 적기 때문에, 비즈니스 로직의 가독성과 유지보수성을 챙기는 것이 훨씬 유의미한 결정이라고 판단했습니다"

---

### 질문 4: "도메인별로 다른 Annotation을 만든 이유는?"

**답변:**
- "더 간편하게 사용하기 위해서입니다"
- "도메인별로 다른 설정(finder, type)을 명확하게 표현할 수 있습니다"
- "실수로 잘못된 finder나 type을 지정하는 것을 방지할 수 있습니다"

---

### 질문 5: "이 방식의 장단점은?"

**장점:**
- 비즈니스 로직과 보안 로직 완전 분리
- 코드 중복 제거
- 가독성 향상
- 유지보수 용이

**단점:**
- 리플렉션 사용으로 인한 약간의 성능 오버헤드
- AOP 동작 방식 이해 필요
- 디버깅이 다소 어려울 수 있음

---

## 정리

✅ **문제 상황을 명확하게 표현한다**

✅ **해결 방법을 구체적으로 설명한다**

✅ **기술 선택 이유를 포함한다**

✅ **구현 내용을 간단히 설명한다**

✅ **면접 대비 질문을 미리 준비한다**
