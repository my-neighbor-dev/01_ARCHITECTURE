# 9. 정리 및 Q&A

## 핵심 정리

### 1. 토큰은 쿠키에 저장하여 XSS 방지

- Response Body에 토큰을 보내면 JavaScript로 접근 가능
- HttpOnly 쿠키를 사용하여 JavaScript 접근 차단
- Access Token과 Refresh Token 모두 쿠키로 전송하는 것이 더 안전

---

### 2. 문제 해결 과정: 종이와 펜으로 생각하기

- 공격자가 옆에 있다고 가정하고 해결 방법 생각하기
- 단계별로 최적화하는 과정
- 핵심: 임시 데이터는 캐시의 TTL 기능 활용

---

### 3. Redis Rate Limiting으로 무분별한 로그인 시도 방지

- Redis의 TTL 기능으로 자동 만료 구현
- INCR + TTL 조합으로 간단하게 구현
- Device ID, 전화번호, IP 기반 다중 체크

---

### 4. Device ID와 IP로 다층 방어

- 전화번호만으로는 여러 계정 공격을 막을 수 없음
- Device ID와 IP를 함께 사용하여 더 강력한 보안
- 여러 기준을 동시에 체크하여 다층 방어 구축

---

### 5. 문제 해결 중심의 이력서 작성

- 문제 상황을 명확하게 표현
- 해결 방법을 구체적으로 설명
- 기술 선택 이유를 포함

---

## Q&A

### Q1: 앱에서는 쿠키를 어떻게 사용하나요?

**A:** 앱에서는 쿠키를 받아서 파싱한 후, 별도 저장소에 저장하고 이후 요청에 Authorization Header로 전송합니다. 또는 서버에서 쿠키와 Authorization Header를 모두 지원하도록 구현합니다.

---

### Q2: 쿠키 삭제하고 VPN으로 IP를 계속 바꾸면 뚫리지 않나요?

**A:** 
- 쿠키 삭제로 Device ID를 우회하고, VPN으로 IP를 변경하면 현재 구현으로는 우회 가능합니다
- **하지만 전화번호 기반 제한은 우회할 수 없습니다** (가장 강력한 방어)
- 실무에서는 다음과 같이 강화합니다:
  1. **전화번호 기반 제한 강화**: 5번 → 3번으로 축소, 실패 횟수 누적 (24시간 기준)
  2. **Device Fingerprinting**: 쿠키 외에도 브라우저 특성(User-Agent, Screen 등)을 조합하여 디바이스 식별
  3. **CAPTCHA 도입**: 3번 실패 후 CAPTCHA 요구로 자동화 공격 차단
  4. **계정 잠금**: 5번 연속 실패 시 24시간 계정 잠금
- **핵심**: 완벽한 차단은 불가능하지만, 여러 레이어의 방어로 공격 비용을 크게 증가시킬 수 있습니다

---

## 스터디 후 생각해볼 점

### 추가 과제: 마지막 시간 기준 TTL 적용

**요구사항:**
- 현재 구현: 첫 요청 시간을 기준으로 1시간 TTL 설정
- 새로운 요구사항: **마지막 요청 시간을 기준으로 1시간 TTL 적용**

**예시:**
```
현재 구현:
- 14:00 첫 요청 → TTL 1시간 (15:00까지)
- 14:30 요청 → TTL은 여전히 15:00까지 (변경 없음)

새로운 요구사항:
- 14:00 첫 요청 → TTL 1시간 (15:00까지)
- 14:30 요청 → TTL을 15:30까지 연장 (마지막 시간 기준)
```

**생각해볼 점:**
- Redis에서 마지막 요청 시간을 기준으로 TTL을 연장하려면 어떻게 해야 할까?
- `EXPIRE` 명령어를 매번 호출하면 될까?
- 성능에 영향을 주지 않으려면 어떻게 최적화할 수 있을까?
- 다른 방법은 없을까?

**다음 스터디에서 함께 고민해봅시다!** 🤔

---

## 마무리

이번 스터디를 통해 다음을 배웠습니다:

- ✅ 토큰을 쿠키에 저장하는 이유
- ✅ 문제 해결 과정을 단계별로 생각하는 방법
- ✅ 캐시의 특성을 활용해서 문제를 해결하는 방법
- ✅ Redis Rate Limiting 구현 방법
- ✅ 문제 해결 중심의 이력서 작성 방법

